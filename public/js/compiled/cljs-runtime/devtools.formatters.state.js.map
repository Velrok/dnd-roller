{"version":3,"sources":["devtools/formatters/state.cljs"],"mappings":";;AAiBA,AAAA,AAAeA;AAEf,AAAA,AAAMC;AAAN,AACE,AAAA,AAAA,AAAOD;;AAET,AAAA,AAAME;AAAN,AAAA;;AAGA,AAAA,AAAME;AAAN,AAAA,AACS,AAACH;AADV;AAAA,AAAA,AAAA,AAAAE,AAAA;;;AAEEH;;AAEF,AAAA,AAAA,AAAAK,AAAMM;AAAN,AAAA,AAAAL,AAAA;AAAA,AAAA,AAAAC,AAAA,AAAA;AAAA,AAAA,AAAAC,AAAA;;AAAA,AAAA,AAAA,AAAAA,AAAAD;AAAA,AAAA,AAAAD,AAAA,AAAA,AAAAE;;AAAA,AAAA,AAAAA,AAAA;;;;AAAA;;;;AAAA,AAAAC,AAAA,AAAA,AAAA,AAAA,AAAAH,AAAA,AAAA,AAAAI,AAAA,AAAAJ,AAAA,AAAA,AAAA,AAAA;AAAA,AAAA,AAAAK,AAAA,AAAA,AAAA,AAAAF;;;AAAA,AAAA,AAAA,AAAA,AAAME,AAAuBM,AAAIC;AAAjC,AAAA,AACS,AAACjB;AADV;AAAA,AAAA,AAAA,AAAAE,AAAA;;;AAEE,AAAMH,AAAgB,AAACmB,AAAMF,AAAEjB,AAAgBkB;;;AAFjD,AAAA,AAAA,AAAMP;;AAAN;AAAA,AAAA,AAAA,AAAAC,AAAMD;AAAN,AAAA,AAAAE,AAAA,AAAAC,AAAAF;AAAAA,AAAA,AAAAG,AAAAH;AAAA,AAAA,AAAAI,AAAA;AAAA,AAAA,AAAAA,AAAAH,AAAAD;;;AAAA,AAMA,AAAA,AAAMQ,AAAiCC;AAAvC,AACE,AAAA,AAACC,AAAsBC,AAAgBC,AAAKH;;AAE9C,AAAA,AAAMI;AAAN,AACE,AAAA,AAAU,AAACrB;;AAEb,AAAA,AAAMsB,AAAcL;AAApB,AACE,AAAMM,AAAQ,AAACF;AAAf,AACE,AAAA,AAACI;AAADD;AAAA,AAAO,AAAAA,AAAcP;;AAAQM;;AAEjC,AAAA,AAAMG;AAAN,AACE,AAAChB,AAAM,AAACW;;AAEV,AAAA,AAAMM;AAAN,AACE,AAACC,AAAO,AAACP;;AAEX,AAAA,AAAA,AAAApB,AAAM4B;AAAN,AAAA,AAAA3B,AAAA;AAAA,AAAA,AAAAC,AAAA,AAAA;AAAA,AAAA,AAAAC,AAAA;;AAAA,AAAA,AAAA,AAAAA,AAAAD;AAAA,AAAA,AAAAD,AAAA,AAAA,AAAAE;;AAAA,AAAA,AAAAA,AAAA;;;;AAAA;;;;AAAA,AAAAC,AAAA,AAAA,AAAA,AAAA,AAAAH,AAAA,AAAA,AAAAI,AAAA,AAAAJ,AAAA,AAAA,AAAA,AAAA;AAAA,AAAA,AAAA2B,AAAA,AAAA,AAAA,AAAAxB;;;AAAA,AAAA,AAAA,AAAA,AAAAyB,AAAMD,AAAsBM;AAA5B,AAAA,AAAAJ,AAAAD;AAAA,AAAAE,AAAAD,AAAA,AAAA,AAAiCK;AAAjC,AACE,AACE,AAASD;AAAGA;;AADd,AAGE,AAAAE,AAAUF;AAAGA;;AAHf,AAIE,AAAK,AAASA,AACT,AAASC;AAAiB,AAAGD,AAAEC;;AALtC,AAME,AAASD;AAAGA;;AANd,AAAA;;;;;;;;AADF,AAAA,AAAA,AAAMN;;AAAN;AAAA,AAAA,AAAA,AAAAI,AAAMJ;AAAN,AAAA,AAAAK,AAAA,AAAAxB,AAAAuB;AAAAA,AAAA,AAAAtB,AAAAsB;AAAA,AAAA,AAAArB,AAAA;AAAA,AAAA,AAAAA,AAAAsB,AAAAD;;;AAAA,AAUA,AAAA,AAAA,AAAAhC,AAAMqC;AAAN,AAAA,AAAApC,AAAA;AAAA,AAAA,AAAAC,AAAA,AAAA;AAAA,AAAA,AAAAC,AAAA;;AAAA,AAAA,AAAA,AAAAA,AAAAD;AAAA,AAAA,AAAAD,AAAA,AAAA,AAAAE;;AAAA,AAAA,AAAAA,AAAA;;;;AAAA;;;;AAAA,AAAAC,AAAA,AAAA,AAAA,AAAA,AAAAH,AAAA,AAAA,AAAAI,AAAA,AAAAJ,AAAA,AAAA,AAAA,AAAA;AAAA,AAAA,AAAAoC,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAAjC;;;AAAA,AAAA,AAAA,AAAA,AAAAkC,AAAMD,AAAmBM,AAAKC;AAA9B,AAAA,AAAAL,AAAAD;AAAA,AAAAP,AAAAQ,AAAA,AAAA,AAAqCM;AAArC,AACE,AAAMV,AAAe,AAAA,AAAI,AAACV,AACD,AAACqB;AAEpBC,AAAe;AAAAC;AAAA,AAAA,AAAAC,AAAAD;AAAA,AAAAjB,AAAAkB,AAAA,AAAA,AAAMC;AAAN,AAAAnB,AAAAkB,AAAA,AAAA,AAAQf;AAAR,AACE,AAEE,AAAAiB,AAAKN;AAAL,AAAA,AAAAM;AAAgB,AAAYD,AAAEN;;AAA9BO;;;AACA,AAACvB,AAAqBsB;;AAHxB,AAKE,AAAYhB,AAAEU;AACd,AAACQ,AAAqBF,AAAEf;;AAN1B;;;;;AAJvB,AAWE,AAACX,AAAKuB,AAAEJ;;;AAZZ,AAAA,AAAA,AAAMN;;AAAN;AAAA,AAAA,AAAA,AAAAG,AAAMH;AAAN,AAAA,AAAAI,AAAA,AAAAhC,AAAA+B;AAAAA,AAAA,AAAA9B,AAAA8B;AAAAE,AAAA,AAAAjC,AAAA+B;AAAAA,AAAA,AAAA9B,AAAA8B;AAAA,AAAA,AAAA7B,AAAA;AAAA,AAAA,AAAAA,AAAA8B,AAAAC,AAAAF;;;AAAA,AAcA,AAAA,AAAMa,AAAoBC,AAActC;AAAxC,AACE,AACE,AAACuC,AAAKD;AAAiC,AAAA,AAACE,AAAkB,AAACC,AAAIH,AAAetC;;AADhF,AAEE,AAAC0C,AAAYJ;AAA0B,AAACjB,AAAkB,AAACsB,AAAY,AAAKC,AAAEC;AAAP,AAAA,AAAWD,AAAEC;AAAIP,AAAetC;;AAFzG,AAGE,AAAK,AAAC8C,AAAKR,AACN,AAACS,AAAUT,AAActC,AACzB,AAAI,AAASA,AACT,AAAAoB,AAAUpB,AACV,AAACgD,AAAShD;AAAoBA;;AAPzC,AAQE,AAAK,AAAC8C,AAAKR,AACN,AAACS,AAAUT,AAActC;AAAS,AAACqB,AAAkB,AAACsB,AAAY,AAAKC,AAAEC;AAAP,AAAA,AAAWD,AAAEC;AAAIP,AAAetC;;AATzG;;;;;;AAqBF,AAAA,AAAMiD,AACH3C,AAAQ4C;AADX,AAEE,AAAMC,AAAS,AAAA,AAAA,AAAM,AAAK,AAACC,AAAQF,AACT,AAACX,AAAKjC,AACf,AAAA,AAAA,AAACS,AAAImC;AAChBG,AAAU,AAAAlB,AAAKgB;AAAL,AAAA,AAAAhB;AAAA,AACK,AAAI,AAAAf,AAAU+B,AACV,AAASA,AACT,AAASA,AAEb,AAAA,AAACG,AAAE,AAACC,AAAML;;AALff;;;AAHhB,AASE,AAAMkB;AAAN,AACE,AAACN,AAAUzC,AAAQ6C;;AADrB;;;AAGJ,AAAA,AAAMK,AACHlD,AAAQ4C,AAAIO;AADf,AAIE,AAAM,AAACR,AAAS3C,AAAQ4C;AAAxB,AACE,AAAAQ,AAAID;AAAJ,AAAA,AAAAC;AAAAA;;AAAA;;;AADF;;;AAGF,AAAA,AAAMC,AACHrD,AAAQmD;AADX,AAEE,AAAMG,AAAoB,AAAClD;AAA3B,AAGE,AAAM,AAACuC,AAASW,AAAoBtD;AAApC,AACE,AAACuD,AAAK,AAAAH,AAAID;AAAJ,AAAA,AAAAC;AAAAA;;AAAA;;AAAa,AAAA,AAAA,AAAC3C,AAAIT;;AAD1B;;;AAGJ,AAAA,AAAMwD,AACHxD,AAAQ4C,AAAIO;AADf,AAEE,AAAMM,AAAa,AAAC1B,AAAmB/B,AAAQ4C;AAA/C,AACE,AAAM,AAAA,AAAA,AAAOa;AAAb,AACE,AAACF,AAAK,AAAAH,AAAID;AAAJ,AAAA,AAAAC;AAAAA;;AAAA;;AAAaK;;AADrB;;;AAGJ,AAAA,AAAMC,AAAkBC,AAAUjE;AAAlC,AACE,AAAMsC,AAAc,AAAC7B;AAArB,AACE,AAAAiD,AAAI,AAACF,AAA2BlB,AAActC,AAAOiE;AAArD,AAAA,AAAAP;AAAAA;;AAAA,AAAAA,AACI,AAACC,AAAyBrB,AAAc2B;AAD5C,AAAA,AAAAP;AAAAA;;AAAA,AAAAA,AAEI,AAACI,AAAUxB,AAActC,AAAOiE;AAFpC,AAAA,AAAAP;AAAAA;;AAGIO;;;;;AAER,AAAA,AAAMC,AAAkClE;AAAxC,AACE,AAAA,AAACC,AAAsBC,AAAkB8D,AAAiBhE;;AAE5D,AAAA,AAAMmE;AAAN,AACE,AAAA,AAAY,AAACpF;;AAEf,AAAA,AAAYqF;AAAZ,AACE,AAACC,AAAQ,AAAA,AAAoB,AAACtF;;AAEhC,AAAA,AAAMuF,AAAuBC,AAAM3C;AAAnC,AACE,AAAI,AAAA,AAAA,AAAOA;AACT,AAAA,AAAC4C,AAAMD,AAAyB3C;;AAChC,AAAA,AAAC6C,AAAOF;;;AAEZ,AAAA,AAAMG;AAAN,AACE,AAAA,AAAsB,AAAC3F;;AAEzB,AAAA,AAAM4F,AAAyBJ,AAAM3C;AAArC,AACE,AAAI,AAAA,AAAA,AAAOA;AACT,AAAA,AAAC4C,AAAMD,AAA2B3C;;AAClC,AAAA,AAAC6C,AAAOF;;;AAEZ,AAAA,AAAMK;AAAN,AACE,AAAA,AAAe,AAAC7F;;AAElB,AAAA,AAAM8F,AAAkBN,AAAM3C;AAA9B,AACE,AAAI,AAAA,AAAA,AAAOA;AACT,AAAA,AAAC4C,AAAMD,AAAoB3C;;AAC3B,AAAA,AAAC6C,AAAOF;;;AAEZ,AAAA,AAAMO,AAAoBP;AAA1B,AACMA,AACA,AAAA,AAACM,AACD,AAAA,AAACF","names":["devtools.formatters.state/*current-state*","devtools.formatters.state/valid-current-state?","devtools.formatters.state/get-default-state","js/Error","devtools.formatters.state/get-current-state","var_args","args__4736__auto__","len__4730__auto__","i__4731__auto__","argseq__4737__auto__","cljs.core/IndexedSeq","devtools.formatters.state/update-current-state!","seq26908","G__26909","cljs.core/first","cljs.core/next","self__4717__auto__","f","args","cljs.core.apply.cljs$core$IFn$_invoke$arity$3","devtools.formatters.state/push-object-to-current-history!","object","devtools.formatters.state.update_current_state_BANG_.cljs$core$IFn$_invoke$arity$variadic","cljs.core/update","cljs.core/conj","devtools.formatters.state/get-current-history","devtools.formatters.state/is-circular?","history","p1__26912#","cljs.core/some","devtools.formatters.state/get-last-object-from-current-history","devtools.formatters.state/get-second-last-object-from-current-history","cljs.core/second","devtools.formatters.state/present-path-segment","p__26917","vec__26921","cljs.core.nth.cljs$core$IFn$_invoke$arity$3","seq26914","G__26915","v","starting-index","cljs.core/Keyword","devtools.formatters.state/seek-path-segment","p__26933","vec__26934","seq26928","G__26929","G__26930","coll","val","seq'd-map?","cljs.core/meta","*","p__26937","vec__26938","k","and__4120__auto__","devtools.formatters.state.present_path_segment.cljs$core$IFn$_invoke$arity$variadic","devtools.formatters.state/build-path-segment","parent-object","cljs.core/map?","devtools.formatters.state.seek_path_segment.cljs$core$IFn$_invoke$arity$variadic","cljs.core/seq","cljs.core/sequential?","cljs.core.map_indexed.cljs$core$IFn$_invoke$arity$2","i","x","cljs.core/set?","cljs.core/contains?","cljs.core/integer?","devtools.formatters.state/mapping?","obj","first-kw","cljs.core/vector?","valid-kw?","cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2","cljs.core/count","devtools.formatters.state/ignore-path-in-fake-vector","path","or__4131__auto__","devtools.formatters.state/find-path-in-fake-vector","second-last-history","cljs.core.conj.cljs$core$IFn$_invoke$arity$2","devtools.formatters.state/find-path","path-segment","devtools.formatters.state/extend-path-info","path-info","devtools.formatters.state/add-object-to-current-path-info!","devtools.formatters.state/get-current-path-info","devtools.formatters.state/prevent-recursion?","cljs.core/boolean","devtools.formatters.state/set-prevent-recursion","state","cljs.core.assoc.cljs$core$IFn$_invoke$arity$3","cljs.core.dissoc.cljs$core$IFn$_invoke$arity$2","devtools.formatters.state/get-managed-print-level","devtools.formatters.state/set-managed-print-level","devtools.formatters.state/get-depth-budget","devtools.formatters.state/set-depth-budget","devtools.formatters.state/reset-depth-limits"],"sourcesContent":["(ns devtools.formatters.state)\n\n; - state management --------------------------------------------------------------------------------------------------------\n;\n; we have to maintain some state:\n; a) to prevent infinite recursion in some pathological cases (https://github.com/binaryage/cljs-devtools/issues/2)\n; b) to keep track of printed objects to visually signal circular data structures\n;\n; We dynamically bind *current-config* to the config passed from \"outside\" when entering calls to our API methods.\n; Initially the state is empty, but we accumulate there a history of seen values when rendering individual values\n; in depth-first traversal order. See alt-printer-impl where we re-bind *current-config* for each traversal level.\n; But there is a catch. For larger data structures our printing methods usually do not print everything at once.\n; We can include so called \"object references\" which are just placeholders which can be expanded later\n; by DevTools UI (when user clicks a disclosure triangle).\n; For proper continuation in rendering of those references we have to carry our existing state over.\n; We use \"config\" feature of custom formatters system to pass current state to future API calls.\n\n(def ^:dynamic *current-state* nil)\n\n(defn valid-current-state? []\n  (some? *current-state*))\n\n(defn get-default-state []\n  {})\n\n(defn get-current-state []\n  {:pre [(valid-current-state?)]}\n  *current-state*)\n\n(defn update-current-state! [f & args]\n  {:pre [(valid-current-state?)]}\n  (set! *current-state* (apply f *current-state* args)))\n\n; -- high level API ---------------------------------------------------------------------------------------------------------\n\n(defn push-object-to-current-history! [object]\n  (update-current-state! update :history conj object))\n\n(defn get-current-history []\n  (:history (get-current-state)))\n\n(defn is-circular? [object]\n  (let [history (get-current-history)]\n    (some #(identical? % object) history)))\n\n(defn get-last-object-from-current-history []\n  (first (get-current-history)))                                                                                              ; note the list is reversed\n\n(defn get-second-last-object-from-current-history []\n  (second (get-current-history)))                                                                                              ; note the list is reversed\n\n(defn present-path-segment [v & [starting-index]]\n  (cond\n    (string? v) v\n    ;; we'd like to preserve keywords for easy get\n    (keyword? v) v\n    (and (number? v)\n         (number? starting-index)) (+ v starting-index)     ;; ensures indexing in very large objects\n    (number? v) v\n    :else \"?\"))\n\n(defn seek-path-segment [coll val & [seq'd-map?]]\n  (let [starting-index (-> (get-last-object-from-current-history)\n                           (meta)\n                           :index)\n        *              (fn [[k v]]\n                         (cond\n                           ;; we need to know the paths for keywords, these are clickable\n                           (and seq'd-map? (identical? k val))\n                           (present-path-segment k)\n\n                           (identical? v val)\n                           (present-path-segment k starting-index)))]\n    (some * coll)))\n\n(defn build-path-segment [parent-object object]\n  (cond\n    (map? parent-object)                   (seek-path-segment (seq parent-object) object true)\n    (sequential? parent-object)            (seek-path-segment (map-indexed (fn [i x] [i x]) parent-object) object)\n    (and (set? parent-object)\n         (contains? parent-object object)\n         (or (string? object)\n             (keyword? object)\n             (integer? object)))           object           ;; if set has the simple object, return the object instead.\n    (and (set? parent-object)                               ;; in composite objects in sets, return the index in the set.\n         (contains? parent-object object)) (seek-path-segment (map-indexed (fn [i x] [i x]) parent-object) object)))\n\n;; This function checks a unique situation of looping an immediate child element `obj` of a parent element `history`\n;; say we have a general map {:a 2 :b {:gh 45} :c 4}\n;; and we call devtools.formatters.core/body-api-call with the map, the map ends up in\n;; devtools.formatters.markup/<details> which then calls devtools.formatters.markup/body-lines\n;; where the map will get seq'd resulting in ([:a 2] [:b {:gh 45}] [:c 4])\n;; these 3 vectors will then be pushed to history which will result in an issue when generating the path\n;; for example if we are looping over at `obj` as 2 and `history` as `[:a 2]` `build-path-segment` will return\n;; the path as 1 since the immediate history is a vector instead of a map.\n;; This function detects the condition that this is the case and then the next operation will be to\n;; get the first item in the vector which is the path.\n(defn mapping?\n  [history obj]\n  (let [first-kw (when (and (vector? obj)\n                            (map? history))\n                   (nth obj 0 nil))\n        valid-kw? (and first-kw\n                       (or (keyword? first-kw)\n                           (string? first-kw)\n                           (number? first-kw))\n                       ;; intentionally delaying realizing the whole vector\n                       (= (count obj) 2))]\n    (when valid-kw?\n      (contains? history first-kw))))\n\n(defn ignore-path-in-fake-vector\n  [history obj path]\n  ;; if the current item we are looping at is an artificial vector (explained at `mapping` above),\n  ;; don't append to the path\n  (when (mapping? history obj)\n    (or path [])))\n\n(defn find-path-in-fake-vector\n  [history path]\n  (let [second-last-history (get-second-last-object-from-current-history)]\n    ;; if the previous item is an artificial vector, lets append to the path info but take the first item\n    ;; in the artificial vector as the path. (Explained in `mapping` above)\n    (when (mapping? second-last-history history)\n      (conj (or path []) (nth history 0 nil)))))\n\n(defn find-path\n  [history obj path]\n  (let [path-segment (build-path-segment history obj)]\n    (when (some? path-segment)\n      (conj (or path []) path-segment))))\n\n(defn extend-path-info [path-info object]\n  (let [parent-object (get-last-object-from-current-history)]\n    (or (ignore-path-in-fake-vector parent-object object path-info)\n        (find-path-in-fake-vector parent-object path-info)\n        (find-path parent-object object path-info)\n        path-info)))\n\n(defn add-object-to-current-path-info! [object]\n  (update-current-state! update :path-info extend-path-info object))\n\n(defn get-current-path-info []\n  (:path-info (get-current-state)))\n\n(defn ^bool prevent-recursion? []\n  (boolean (:prevent-recursion (get-current-state))))\n\n(defn set-prevent-recursion [state val]\n  (if (some? val)\n    (assoc state :prevent-recursion val)\n    (dissoc state :prevent-recursion)))\n\n(defn get-managed-print-level []\n  (:managed-print-level (get-current-state)))\n\n(defn set-managed-print-level [state val]\n  (if (some? val)\n    (assoc state :managed-print-level val)\n    (dissoc state :managed-print-level)))\n\n(defn get-depth-budget []\n  (:depth-budget (get-current-state)))\n\n(defn set-depth-budget [state val]\n  (if (some? val)\n    (assoc state :depth-budget val)\n    (dissoc state :depth-budget)))\n\n(defn reset-depth-limits [state]\n  (-> state\n      (set-depth-budget nil)\n      (set-managed-print-level nil)))\n"]}